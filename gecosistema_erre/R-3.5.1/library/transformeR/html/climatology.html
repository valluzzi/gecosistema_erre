<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><title>R: Compute a grid climatology</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<link rel="stylesheet" type="text/css" href="R.css" />
</head><body>

<table width="100%" summary="page for climatology {transformeR}"><tr><td>climatology {transformeR}</td><td style="text-align: right;">R Documentation</td></tr></table>

<h2>Compute a grid climatology</h2>

<h3>Description</h3>

<p>Calculates the climatology (i.e., complete temporal aggregation, typically the mean)
of the input grid.
</p>


<h3>Usage</h3>

<pre>
climatology(grid, clim.fun = list(FUN = "mean", na.rm = TRUE),
  by.member = TRUE, parallel = FALSE, max.ncores = 16, ncores = NULL)
</pre>


<h3>Arguments</h3>

<table summary="R argblock">
<tr valign="top"><td><code>grid</code></td>
<td>
<p>Input grid</p>
</td></tr>
<tr valign="top"><td><code>clim.fun</code></td>
<td>
<p>Function to compute the climatology. This is specified as a list,
indicating the name of the aggregation function in first place (as character), and other optional arguments
to be passed to the aggregation function. Default to mean (i.e., <code>clim.fun = list(FUN="mean",na.rm = TRUE)</code>).</p>
</td></tr>
<tr valign="top"><td><code>by.member</code></td>
<td>
<p>Logical. In case of multimember grids, should the climatology be computed sepparately
for each member (<code>by.member=TRUE</code>), or a single climatology calculated from the ensemble mean
(<code>by.member=FALSE</code>)?. Default to <code>TRUE</code>.</p>
</td></tr>
<tr valign="top"><td><code>parallel</code></td>
<td>
<p>Logical. Should parallel execution be used?</p>
</td></tr>
<tr valign="top"><td><code>max.ncores</code></td>
<td>
<p>Integer. Upper bound for user-defined number of cores.</p>
</td></tr>
<tr valign="top"><td><code>ncores</code></td>
<td>
<p>Integer number of cores used in parallel computation. Self-selected number of
cores is used when <code>ncpus = NULL</code> (the default), or when <code>maxcores</code> exceeds the default <code>ncores</code> value.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Two attributes are appended to the grid: 
</p>

<ul>
<li> <p><code>climatology:fun</code>, added to the <code>Data</code> component of the grid,
indicating the function used to compute the climatology.
</p>
</li>
<li> <p><code>season</code>, added to the <code>Dates</code> component (if not yet existing), in order to provide information
on the season for which the climatology has been computed.
</p>
</li></ul>



<h3>Value</h3>

<p>A grid corresponding to the climatology. See details.
</p>


<h3>Parallel Processing</h3>

<p>Parallel processing is enabled using the <span class="pkg">parallel</span> package. 
Parallelization is undertaken by a FORK-type parallel socket cluster formed by <code>ncores</code>.
If <code>ncores</code> is not specified (default), <code>ncores</code> will be one less than the autodetected number of cores.
The maximum number of cores used for parallel processing can be set with the <code>max.ncores</code> argument, 
although this will be reset to the auto-detected number of cores minus 1 if this number is exceeded. Note that not all 
code, but just some critical loops within the function are parallelized.
</p>
<p>In practice, parallelization does not always result in smaller execution times, due to the parallel overhead.
However, parallel computing may potentially provide a significant speedup for the 
particular case of large multimember datasets or large grids.
</p>
<p>Parallel computing is currently not available for Windows machines.
</p>


<h3>Author(s)</h3>

<p>J. Bedia
</p>


<h3>See Also</h3>

<p><code><a href="plotClimatology.html">plotClimatology</a></code>, for plotting climatologies.
<code><a href="persistence.html">persistence</a></code>, for a special case in which the temporal autocorrelation function is applied.
</p>


<h3>Examples</h3>

<pre>
# Station data:
# Mean surface temperature
data("VALUE_Iberia_tas")
st_mean_clim &lt;- climatology(VALUE_Iberia_tas)
str(st_mean_clim)
plotClimatology(st_mean_clim, backdrop.theme = "coastline")
# Standard deviation of surface temperature
st_sd_clim &lt;- climatology(VALUE_Iberia_tas, clim.fun = list(FUN = sd, na.rm = TRUE))
plotClimatology(st_sd_clim, backdrop.theme = "coastline")

# July surface temp forecast climatology
data("CFS_Iberia_tas")
# Aggregate all members before computing the climatology
t_mean.clim &lt;- climatology(CFS_Iberia_tas,
                           by.member = FALSE)
# Note the new attributes, and that time dimension is preserved as a singleton
str(t_mean.clim$Data)
str(t_mean.clim$Dates)
# Compute a climatology for each member sepparately
t_mean_9mem.clim &lt;- climatology(CFS_Iberia_tas,
                                by.member = TRUE)
str(t_mean_9mem.clim$Data)
# 9 different climatologies, one for each member
</pre>

<hr /><div style="text-align: center;">[Package <em>transformeR</em> version 1.4.2 <a href="00Index.html">Index</a>]</div>
</body></html>
