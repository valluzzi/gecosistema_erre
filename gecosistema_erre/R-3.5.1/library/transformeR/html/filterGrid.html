<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><title>R: Time filtering</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<link rel="stylesheet" type="text/css" href="R.css" />
</head><body>

<table width="100%" summary="page for filterGrid {transformeR}"><tr><td>filterGrid {transformeR}</td><td style="text-align: right;">R Documentation</td></tr></table>

<h2>Time filtering</h2>

<h3>Description</h3>

<p>Apply a filter along the time dimension of a grid
</p>


<h3>Usage</h3>

<pre>
filterGrid(grid, window.width, method = c("convolution", "recursive"),
  sides = 1, parallel = FALSE, max.ncores = 16, ncores = NULL, ...)
</pre>


<h3>Arguments</h3>

<table summary="R argblock">
<tr valign="top"><td><code>grid</code></td>
<td>
<p>Input grid (possibly multimember)</p>
</td></tr>
<tr valign="top"><td><code>window.width</code></td>
<td>
<p>An integer specifying the moving window width. This is in the same temporal units 
as the input grid. The function internally converts this value to a vector of filter coefficients of the
form <code>rep(1/n,n)</code>. See <code><a href="../../stats/html/filter.html">filter</a></code> for details.</p>
</td></tr>
<tr valign="top"><td><code>method</code></td>
<td>
<p>Either <code>"convolution"</code> or <code>"recursive"</code>. The <code>"convolution"</code>
option (Default) performs a <em>moving average</em>, while <code>"recursive"</code> applies an autoregressive model.
See <code><a href="../../stats/html/filter.html">filter</a></code> for details.</p>
</td></tr>
<tr valign="top"><td><code>sides</code></td>
<td>
<p>Used for <code>"convolution"</code> filters only. If <code>sides = 1</code> the filter coefficients
are for past values only; if <code>sides = 2</code> they are centred around lag 0.
See <code>filter</code> for more details.</p>
</td></tr>
<tr valign="top"><td><code>parallel</code></td>
<td>
<p>Logical. Should parallel execution be used?</p>
</td></tr>
<tr valign="top"><td><code>max.ncores</code></td>
<td>
<p>Integer. Upper bound for user-defined number of cores.</p>
</td></tr>
<tr valign="top"><td><code>ncores</code></td>
<td>
<p>Integer number of cores used in parallel computation. Self-selected number of
cores is used when <code>ncpus = NULL</code> (the default), or when <code>maxcores</code> exceeds the default <code>ncores</code> value.</p>
</td></tr>
<tr valign="top"><td><code>...</code></td>
<td>
<p>Further arguments passed to <code>filter</code>. Worth to mention here the <code>circular</code> argument,
used in moving averages. See <code><a href="../../stats/html/filter.html">filter</a></code> for details.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A wrapper of function <code><a href="../../stats/html/filter.html">filter</a></code>
</p>


<h3>Value</h3>

<p>A time-filtered grid.
</p>


<h3>Parallel Processing</h3>

<p>Parallel processing is enabled using the <span class="pkg">parallel</span> package. 
Parallelization is undertaken by a FORK-type parallel socket cluster formed by <code>ncores</code>.
If <code>ncores</code> is not specified (default), <code>ncores</code> will be one less than the autodetected number of cores.
The maximum number of cores used for parallel processing can be set with the <code>max.ncores</code> argument, 
although this will be reset to the auto-detected number of cores minus 1 if this number is exceeded. Note that not all 
code, but just some critical loops within the function are parallelized.
</p>
<p>In practice, parallelization does not always result in smaller execution times, due to the parallel overhead.
However, parallel computing may potentially provide a significant speedup for the 
particular case of large multimember datasets or large grids.
</p>
<p>Parallel computing is currently not available for Windows machines.
</p>


<h3>Author(s)</h3>

<p>J Bedia
</p>


<h3>Examples</h3>

<pre>
data(NCEP_Iberia_ta850)
plot(NCEP_Iberia_ta850[["Data"]][,3,3], ty = 'l')
# Apply a moving average considering 2 different window widths of 30 and 90 days
fgrid30 &lt;- filterGrid(NCEP_Iberia_ta850, method = "convolution", window.width = 30, sides = 1)
lines(fgrid30[["Data"]][,3,3], col = 'red')
fgrid90 &lt;- filterGrid(NCEP_Iberia_ta850, method = "convolution", window.width = 90, sides = 1)
lines(fgrid90[["Data"]][,3,3], col = 'green')
legend("top", c("raw","30-day MA", "90-day MA"), lty = 1, col = c(1,2,3), ncol = 3)
</pre>

<hr /><div style="text-align: center;">[Package <em>transformeR</em> version 1.4.2 <a href="00Index.html">Index</a>]</div>
</body></html>
