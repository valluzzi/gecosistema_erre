<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><title>R: Grid interpolation</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<link rel="stylesheet" type="text/css" href="R.css" />
</head><body>

<table width="100%" summary="page for interpGrid {transformeR}"><tr><td>interpGrid {transformeR}</td><td style="text-align: right;">R Documentation</td></tr></table>

<h2>Grid interpolation</h2>

<h3>Description</h3>

<p>Interpolation of grids (gridded data or stations) into a user-defined grid using nearest-neighbour or bilinear weights.
</p>


<h3>Usage</h3>

<pre>
interpGrid(grid, new.coordinates = list(x = NULL, y = NULL),
  method = c("nearest", "bilinear"), bilin.method = "fields",
  parallel = FALSE, max.ncores = 16, ncores = NULL, ...)
</pre>


<h3>Arguments</h3>

<table summary="R argblock">
<tr valign="top"><td><code>grid</code></td>
<td>
<p>An input grid to be interpolated/regridded.</p>
</td></tr>
<tr valign="top"><td><code>new.coordinates</code></td>
<td>
<p>Definition of the new grid (or points) coordinates, in the form of a list with the x and y components, in this order.
If new coordinates correspond to an irregular grid (e.g. point locations), lengths for x and y must be the same: Each position in x and y correspond to
a new location (a pair of coordinates).</p>
</td></tr>
<tr valign="top"><td><code>method</code></td>
<td>
<p>Method for interpolation. Currently implemented methods are either <code>"bilinear"</code>,
for bilinear interpolation, and <code>"nearest"</code>, for nearest-neighbor interpolation (default).</p>
</td></tr>
<tr valign="top"><td><code>bilin.method</code></td>
<td>
<p>Algorithm chosen for bilinear interpolation. Two options available: <code>"akima"</code> uses <code><a href="../../akima/html/interp.html">interp</a></code> and
<code>"fields"</code> (default) the <code><a href="../../fields/html/interp.surface.grid.html">interp.surface.grid</a></code> algorithm. In case any missing values exist in the input data matrix, 
the <code>"fields"</code> option, able to handle missing values, need to be used. Otherwise, the <code>"akima"</code> option performs much faster.</p>
</td></tr>
<tr valign="top"><td><code>parallel</code></td>
<td>
<p>Logical. Should parallel execution be used?</p>
</td></tr>
<tr valign="top"><td><code>max.ncores</code></td>
<td>
<p>Integer. Upper bound for user-defined number of cores.</p>
</td></tr>
<tr valign="top"><td><code>ncores</code></td>
<td>
<p>Integer number of cores used in parallel computation. Self-selected number of
cores is used when <code>ncpus = NULL</code> (the default), or when <code>maxcores</code> exceeds the default <code>ncores</code> value.</p>
</td></tr>
<tr valign="top"><td><code>...</code></td>
<td>
<p>Further arguments for bilinear interpolation that are passed to function <code><a href="../../akima/html/interp.html">interp</a></code> 
from package <span class="pkg"><a href="../../akima/html/akima.html">akima</a></span>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The output has special attributes in the <code>xyCoords</code> element that indicate that the object
has been interpolated. These attributes are <code>interpolation</code>, which indicates the method used and
<code>resX</code> and <code>resY</code>, for the grid-cell resolutions in the X and Y axes respectively.
It is also possible to pass the interpolator the grid of a previously existing grid dataset using the
<code><a href="getGrid.html">getGrid</a></code> method. See examples.
</p>


<h3>Value</h3>

<p>An interpolated object preserving the structure of the input
</p>


<h3>Parallel Processing</h3>

<p>Parallel processing is enabled using the <span class="pkg">parallel</span> package. 
Parallelization is undertaken by a FORK-type parallel socket cluster formed by <code>ncores</code>.
If <code>ncores</code> is not specified (default), <code>ncores</code> will be one less than the autodetected number of cores.
The maximum number of cores used for parallel processing can be set with the <code>max.ncores</code> argument, 
although this will be reset to the auto-detected number of cores minus 1 if this number is exceeded. Note that not all 
code, but just some critical loops within the function are parallelized.
</p>
<p>In practice, parallelization does not always result in smaller execution times, due to the parallel overhead.
However, parallel computing may potentially provide a significant speedup for the 
particular case of large multimember datasets or large grids.
</p>
<p>Parallel computing is currently not available for Windows machines.
</p>


<h3>Note</h3>

<p>To avoid unnecessary NA values, the function will not extrapolate using a new grid outside the
current extent of the dataset, returning an error message.
</p>


<h3>Author(s)</h3>

<p>J. Bedia, S. Herrera, M. de Felice, M. Iturbide
</p>


<h3>Examples</h3>

<pre>
# boreal winter (DJF) precipitation data for the Iberian Peninsula and the period 1983-2002
data(EOBS_Iberia_pr)
plotClimatology(climatology(EOBS_Iberia_pr))
# Bilinear interpolation to a regular grid of 0.5 degree 
# resolution centered in the Iberian Peninsula
t1 &lt;- interpGrid(EOBS_Iberia_pr, new.coordinates = list(x = seq(-10,5,.5),
                                                        y = seq(36,44,.5)),
                 method = "bilinear",
                 bilin.method = "akima")
plotClimatology(climatology(t1), backdrop.theme = "countries")
# New attributes indicate that the data have been interpolated:
attributes(t1$xyCoords)

# Using the coordinate information of another grid via getGrid()
data(NCEP_Iberia_pr)
t2 &lt;- interpGrid(EOBS_Iberia_pr, new.coordinates = getGrid(NCEP_Iberia_pr),
                 method = "nearest")
plotClimatology(climatology(t2), backdrop.theme = "countries")

#From station data to grid
data(VALUE_Iberia_pr)
plotClimatology(climatology(VALUE_Iberia_pr), backdrop.theme = "countries")
t3 &lt;- interpGrid(VALUE_Iberia_pr, new.coordinates = getGrid(EOBS_Iberia_pr),
                 method = "bilinear")
plotClimatology(climatology(t3), backdrop.theme = "countries")

#From grid to station data
t4 &lt;- interpGrid(EOBS_Iberia_pr, new.coordinates = getGrid(VALUE_Iberia_pr),
                 method = "nearest")
plotClimatology(climatology(t4), backdrop.theme = "countries")
t5 &lt;- interpGrid(EOBS_Iberia_pr, 
               new.coordinates = list(x = c(-6.7, -4.5, 2.5), 
                                      y = c(41.8, 40, 39)))
plotClimatology(climatology(t5), backdrop.theme = "countries")

#From grid to a single point or station
t6 &lt;- interpGrid(grid = EOBS_Iberia_pr, 
                 new.coordinates = list(x = -6.7, y = 41.8))
str(t6$Data)
</pre>

<hr /><div style="text-align: center;">[Package <em>transformeR</em> version 1.4.2 <a href="00Index.html">Index</a>]</div>
</body></html>
